<html>

<head>
  <title>Timers & Things</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>
  <link href="https://fonts.googleapis.com" rel="preconnect" />
  <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
  <link href="https://fonts.googleapis.com/css2?family=Kalam&amp;display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://apoorlywrittenbot.cc/css/FoxyMist/foxymist.css" type="text/css" charset="utf-8" />
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
</head>

<body>
  <script>
    var intervalList = [];
    var latency = {};
    const font_scale = 25;
    var emotes = {};

    var WebFontConfig = {
      google: {
        families: []
      },
      timeout: 1500
    }

    function WebFontLoad() {
      if (WebFontConfig.google.families.length) {
        WebFont.load(WebFontConfig);
      }
    }

    function isOpen(ws) {
      return ws.readyState === ws.OPEN;
    }

    function connectws() {
      let socket = new WebSocket("wss://2bd6aqqafb.execute-api.us-west-2.amazonaws.com/dev");

      let intervalId = window.setInterval(function () {
        if (!isOpen(socket)) return;
        socket.send('ping');
      }, 300000);

      socket.onopen = function (event) {
        const params = new Proxy(new URLSearchParams(window.location.search), {
          get: (searchParams, prop) => searchParams.get(prop),
        });
        let channel = params.channel;

        payload = {
          'route': "sendmessage",
          'action': 'joinchannel',
          'channel': params.channel
        }
        socket.send(JSON.stringify(payload));
      };

      let timers = {};

      function startTimer(timerText, expiration, element) {
        var diff, TTL, minutes, seconds, timerIntervalID;
        function timer() {
          TTL = expiration - ((Date.now() / 1000) | 0);
          diff = TTL - 30;

          minutes = (diff / 60) | 0;
          seconds = (diff % 60) | 0;

          minutes = minutes < 10 ? "0" + minutes : minutes;
          seconds = seconds < 10 ? "0" + seconds : seconds;

          if (TTL <= 0) {
            clearInterval(timerIntervalID);
            element.remove();
          }
          else if (diff <= 0) {
            element.innerHTML = `${timerText}: DONE`;
          }
          else {
            element.innerHTML = `${timerText}: ${minutes}:${seconds}`;
          }
        };
        timer();
        timerIntervalID = setInterval(timer, 1000);
        intervalList.push(timerIntervalID);
      }

      async function getImg(emoteName, size) {
        if (emotes[emoteName]) {
          return new Promise((res, rej) => {
            res(`<img src="https://static-cdn.jtvnw.net/emoticons/v2/${emotes[emoteName]}/dark/3.0" 
                                style="pointer-events: none; height: ${(1080 / font_scale) / 50 * size}px;">`);
          });
        }
        else {
          let response = await fetch(`https://apoorlywrittenbot.cc/public/emote?name=${emoteName}`);
          if (!response.ok) {
            return new Promise((res, rej) => {
              res(emoteName);
            });
          }
          let data = await response.json();
          emotes[emoteName] = data.id;
          return new Promise((res, rej) => {
            res(`<img src="https://static-cdn.jtvnw.net/emoticons/v2/${emotes[emoteName]}/dark/3.0" 
                                style="pointer-events: none; height: ${(1080 / font_scale) / 50 * size}px;">`);
          });
        }
      }

      async function replaceAsync(str, regex, size) {
        const promises = [];
        str.replace(regex, (match, key) => {
          const promise = getImg(key, size);
          promises.push(promise);
        });
        const data = await Promise.all(promises);
        return str.replace(regex, () => data.shift());
      }

      async function redraw(json) { // {"coordinates": {...}, "fonts": [...]}
        WebFontConfig.google.families = json.fonts;
        WebFontLoad();
        await new Promise(r => setTimeout(r, 300)); // race condition?
        for (const interval of intervalList) {
          clearInterval(interval);
        }
        intervalList = [];
        newLatency = {};
        document.getElementById('canvas').innerHTML = '';
        for (const [index, cor] of Object.entries(json.coordinates)) {
          let element = document.createElement("div");
          document.getElementById('canvas').appendChild(element);
          element.style = `font-family: 'Kalam', cursive; position: absolute; top: ${cor.top}%; left: ${cor.left}%; white-space: nowrap; line-height: 1.0;`;
          element.style.border = '2px solid transparent';
          // Latency adjustment
          let diff = ((Date.now() / 1000) | 0) - cor.now;
          for (const ele of cor.elements) {
            let content = await replaceAsync(ele.content, /:([^\s:]+):/g, ele.size);

            if (ele.category == 'text') {
              let subelement = document.createElement("div");
              subelement.style = `color: ${ele.color}; font-size: ${(1080 / font_scale) / 100 * ele.size}px; font-family: ${ele.font}, cursive;`;
              subelement.innerHTML = content;
              element.appendChild(subelement);
            }
            else if (ele.category == 'timer') {
              let subelement = document.createElement("div");
              subelement.style = `color: ${ele.color}; font-size: ${(1080 / font_scale) / 100 * ele.size}px; font-family: ${ele.font}, cursive;`;
              element.appendChild(subelement);
              if (ele.active) {
                if (latency[ele.UUID]) {
                  newLatency[ele.UUID] = latency[ele.UUID]
                }
                else {
                  newLatency[ele.UUID] = diff;
                }
                startTimer(content, ele.expiration + newLatency[ele.UUID], subelement);
              }
            }
          }
        }
        latency = newLatency;
      }

      window.onload = async function () {
        const params = new Proxy(new URLSearchParams(window.location.search), {
          get: (searchParams, prop) => searchParams.get(prop),
        });
        let channel = params.channel;
        let response = await fetch(`https://apoorlywrittenbot.cc/public/json/${channel}`);
        if (!response.ok) {
          throw new Error("HTTP status " + response.status);
        }
        let data = await response.json();
        await redraw(data);
      }

      socket.onmessage = async function (event) {
        const data = JSON.parse(event.data);
        if (data.action == "modaction") {
          if (data.category == "json") {
            document.querySelectorAll('[href*="fonts.googleapis.com/css?"]').forEach(e => e.remove());
            await redraw(data.coordinates);
          }
        }
      };

      socket.onclose = function (event) {
        if (event.wasClean) {
          console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
        } else {
          console.log('[close] Connection died');
        }
        clearInterval(intervalId);
        setTimeout(function () {
          connectws();
        }, 1000);
      };

      socket.onerror = function (error) {
        console.log(`[error]`);
      };
    }

    connectws();

  </script>

  <div id="canvas" style="width: 1920px; height: 1080px;"></div>

</body>

</html>